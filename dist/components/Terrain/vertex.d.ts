declare const Vertex = "uniform vec3 uGlobalOffset;\nuniform sampler2D uHeightData;\nuniform vec2 uTileOffset;\nuniform float uScale;\n\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying float vMorphFactor;\n\n#define TILE_RESOLUTION 64.0\n\nfloat getHeight(vec3 p) {\n  // Assume a 1024x1024 world\n  float lod = 0.0;//log2(uScale) - 6.0;\n  vec2 st = p.xy / 1024.0;\n\n  // Sample multiple times to get more detail out of map\n  float h = 1024.0 * textureLod(uHeightData, st, lod).r;\n  h += 64.0 * textureLod(uHeightData, 16.0 * st, lod).r;\n  h += 4.0 * textureLod(uHeightData, 256.0 * st, lod).r;\n\n  // Square the height, leads to more rocky looking terrain\n  return h * h / 2000.0;\n  //return h / 10.0;\n}\n\nvec3 getNormal() {\n  // Get 2 vectors perpendicular to the unperturbed normal, and create at point at each (relative to position)\n  //float delta = 1024.0 / 4.0;\n  float delta = (vMorphFactor + 1.0) * uScale / TILE_RESOLUTION;\n  vec3 dA = delta * normalize(cross(normal.yzx, normal));\n  vec3 dB = delta * normalize(cross(dA, normal));\n  vec3 p = vPosition;\n  vec3 pA = vPosition + dA;\n  vec3 pB = vPosition + dB;\n\n  // Now get the height at those points\n  float h = getHeight(vPosition);\n  float hA = getHeight(pA);\n  float hB = getHeight(pB);\n\n  // Update the points with their correct heights and calculate true normal\n  p += normal * h;\n  pA += normal * hA;\n  pB += normal * hB;\n  return normalize(cross(pB - p, pA - p));\n}\n\nuniform int uEdgeMorph;\n\n#define EGDE_MORPH_TOP 1\n#define EGDE_MORPH_LEFT 2\n#define EGDE_MORPH_BOTTOM 4\n#define EGDE_MORPH_RIGHT 8\n\n// Poor man's bitwise &\nbool edgePresent(int edge) {\n  int e = uEdgeMorph / edge;\n  return 2 * ( e / 2 ) != e;\n}\n\n#define MORPH_REGION 0.3\n\n// At the edges of tiles morph the vertices, if they are joining onto a higher layer\nfloat calculateMorph(vec3 p) {\n  float morphFactor = 0.0;\n  if( edgePresent(EGDE_MORPH_TOP) && p.y >= 1.0 - MORPH_REGION ) {\n    float m = 1.0 - clamp((1.0 - p.y) / MORPH_REGION, 0.0, 1.0);\n    morphFactor = max(m, morphFactor);\n  }\n  if( edgePresent(EGDE_MORPH_LEFT) && p.x <= MORPH_REGION ) {\n    float m = 1.0 - clamp(p.x / MORPH_REGION, 0.0, 1.0);\n    morphFactor = max(m, morphFactor);\n  }\n  if( edgePresent(EGDE_MORPH_BOTTOM) && p.y <= MORPH_REGION ) {\n    float m = 1.0 - clamp(p.y / MORPH_REGION, 0.0, 1.0);\n    morphFactor = max(m, morphFactor);\n  }\n  if( edgePresent(EGDE_MORPH_RIGHT) && p.x >= 1.0 - MORPH_REGION ) {\n    float m = 1.0 - clamp((1.0 - p.x) / MORPH_REGION, 0.0, 1.0);\n    morphFactor = max(m, morphFactor);\n  }\n\n  return morphFactor;\n}\n\nvoid main() {\n  vMorphFactor = calculateMorph(position);\n  // THIS ISNT GETTING UPDATED !! IT LOOKS LIKE ITS WORKING BUT ITS NOT\n  vec3 uGlobalXY = vec3(uGlobalOffset.x, uGlobalOffset.y, 0.);\n  vPosition = uScale * position + vec3(uTileOffset, 0.0) + uGlobalXY;\n\n  float grid = uScale / TILE_RESOLUTION;\n  vPosition = floor(vPosition / grid) * grid;\n  if( vMorphFactor > 0.0 ) {\n    // Get position that we would have if we were on higher level grid\n    grid = 2.0 * grid;\n    vec3 position2 = floor(vPosition / grid) * grid;\n\n    // Linearly interpolate the two, depending on morph factor\n    vPosition = mix(vPosition, position2, vMorphFactor);\n  }\n\n  // Get height and calculate normal\n  vPosition = vPosition + normal * getHeight(vPosition);\n  vNormal = getNormal();\n  //vNormal = normal;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);\n}";

export { Vertex };
